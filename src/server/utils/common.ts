import crypto from "node:crypto";

import type { Client, Settings, Site } from "~/generated/prisma/client";

import { ClientConfigType } from "./types";

export function compute_hash(str: string) {
  return crypto.createHash("sha256").update(str).digest("hex");
}

export function generateCIDR(network: string, site_id: number, device_id: number, mask_override?: "24" | "32"): string {
  const [address, mask] = network.split("/");
  const ipParts = address.split(".", 4) as [string, string, string, string];
  ipParts[2] = site_id.toString(); // Convert id to string before assigning
  ipParts[3] = device_id.toString(); // Convert id to string before assigning

  return `${ipParts.join(".")}/${mask_override ?? mask}`;
}

export function generateClientConfig(settings: Settings[], site: Site, client: Client, type: ClientConfigType) {
  const wg_network = settings.find((s) => s.name === "wg_network")!.value;

  let DNS = "";
  if (type === ClientConfigType.localOnlyDNS || type === ClientConfigType.allTrafficDNS) {
    DNS = site.DNS ?? "";
  } else if (type === ClientConfigType.localOnlyPiholeDNS || type === ClientConfigType.allTrafficPiholeDNS) {
    DNS = site.piholeDNS ?? "";
  }

  let config = `
    [Interface]
    Address = ${assignClientCIDR(wg_network, site.id, client.id)}
    PrivateKey = ${client.privateKey}
    ${DNS ? `DNS = ${DNS}` : ""}

    [Peer]
    Endpoint = ${site.endpointAddress}
    PublicKey = ${site.publicKey}
    AllowedIPs = ${
      type === ClientConfigType.localOnly ||
      type === ClientConfigType.localOnlyDNS ||
      type === ClientConfigType.localOnlyPiholeDNS
        ? [generateCIDR(wg_network, 0, 0), site.localAddresses].filter(Boolean).join(", ")
        : "0.0.0.0/0, ::/0"
    }
    `;

  config = config.replaceAll(/^\s+/gm, ""); // Remove leading whitespace
  return config;
}

export function generateWgServerConfig(
  settings: Settings[],
  site: Site,
  otherSites: Site[],
  clients: Client[],
): string {
  const wg_network = settings.find((s) => s.name === "wg_network")!.value;

  if (!site.privateKey) {
    return "There's no private key for this site.";
  }

  const config: string[] = [];

  config.push(
    trimSection([
      `
    # Automatically generated by Wireguard Manager 
    # Site: ${site.name}
    `,
    ]),
  );

  const interfaceSection = [
    `
    [Interface]
    PrivateKey = ${site.privateKey}
    Address = ${assignSiteCIRD(wg_network, site.id)}
    ListenPort = ${site.listenPort.toString()}
    `,
  ];
  if (site.postUp) {
    const postUpLines = site.postUp.split("\n").filter((l) => l.trim());
    interfaceSection.push(...postUpLines.map((line) => `PostUp = ${line}`));
  }
  if (site.postDown) {
    const postDownLines = site.postDown.split("\n").filter((l) => l.trim());
    interfaceSection.push(...postDownLines.map((line) => `PostDown = ${line}`));
  }
  config.push(trimSection(interfaceSection));

  if (otherSites.length > 0) {
    config.push(
      `### site to site Peers
      ${otherSites
        .map((s) => {
          return `[Peer]
                  # site: ${s.name}
                  PublicKey = ${s.publicKey}
                  Endpoint = ${s.endpointAddress}
                  PersistentKeepalive = 3600
                  AllowedIPs = ${[generateCIDR(wg_network, s.id, 0, "24"), s.localAddresses].filter(Boolean).join(", ")}
                  `;
        })
        .join("\n")}
      `,
    );
  }

  if (clients.length > 0) {
    config.push(
      `### Clients
      ${clients
        .map((c) => {
          return `[Peer]
                  # ${c.name}
                  PublicKey = ${c.publicKey}
                  AllowedIPs = ${assignSiteClientCIDR(wg_network, site.id, c.id)}
                  `;
        })
        .join("\n")}
      `,
    );
  }

  return config
    .join("\n\n")
    .split("\n")
    .map((line) => line.trim())
    .join("\n")
    .trim();
}

function assignClientCIDR(wg_network: string, site_id: number, client_id: number) {
  // client can talk to all other clients in the wg_network
  // adding 1, because autoincrement starts at 1, which is the site itself
  return generateCIDR(wg_network, site_id, client_id + 1);
}

function assignSiteCIRD(wg_network: string, site_id: number) {
  // keeping it at /16, but maybe it's sufficient if this is /24?
  return generateCIDR(wg_network, site_id, 1);
}

function assignSiteClientCIDR(wg_network: string, site_id: number, client_id: number) {
  // allow only traffic coming directly from the client
  // adding 1, because autoincrement starts at 1, which is the site itself
  return generateCIDR(wg_network, site_id, client_id + 1, "32");
}

function trimSection(section: string[]) {
  return section
    .map((chunk) =>
      chunk
        .split("\n")
        .filter((l) => l.trim())
        .map((l) => l.trim())
        .join("\n"),
    )
    .join("\n");
}
