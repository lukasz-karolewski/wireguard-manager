import { Client, Settings, Site } from "@prisma/client";
import { ClientConfigType } from "./types";

export function generateCIDR(
  network: string,
  site_id: number,
  device_id: number,
  mask_override?: "24" | "32",
): string {
  const [address, mask] = network.split("/");
  const ipParts = address.split(".", 4) as [string, string, string, string];
  ipParts[2] = site_id.toString(); // Convert id to string before assigning
  ipParts[3] = device_id.toString(); // Convert id to string before assigning

  return `${ipParts.join(".")}/${mask_override ?? mask}`;
}

export function generateWgServerConfig(
  settings: Settings[],
  site: Site,
  otherSites: Site[],
  clients: Client[],
): string {
  const wg_network = settings.find((s) => s.name === "wg_network")!.value;

  if (!site.PrivateKey) {
    return "There's no private key for this site.";
  }

  const config: string[] = [];

  config.push(
    trimSection([
      `
    # Automatically generated by Wireguard Manager 
    # Site: ${site.name}
    `,
    ]),
  );

  const interfaceSection = [
    `
    [Interface]
    PrivateKey = ${site.PrivateKey}
    Address = ${assignSiteCIRD(wg_network, site.id)}
    ListenPort = ${site.listenPort}
    `,
  ];
  if (site.postUp) {
    const postUpLines = site.postUp.split("\n").filter((l) => l.trim());
    interfaceSection.push(...postUpLines.map((line) => `PostUp = ${line}`));
  }
  if (site.postDown) {
    const postDownLines = site.postDown.split("\n").filter((l) => l.trim());
    interfaceSection.push(...postDownLines.map((line) => `PostDown = ${line}`));
  }
  config.push(trimSection(interfaceSection));

  otherSites.length &&
    config.push(
      `### site to site Peers
      ${otherSites
        .map((s) => {
          return `[Peer]
                  # site: ${s.name}
                  PublicKey = ${s.PublicKey}
                  Endpoint = ${s.endpointAddress}
                  AllowedIPs = ${[generateCIDR(wg_network, s.id, 0, "24"), s.localAddresses]
                    .filter((v) => v)
                    .join(", ")}
                  `;
        })
        .join("\n")}
      `,
    );

  clients.length &&
    config.push(
      `### Clients
      ${clients
        .map((c) => {
          return `[Peer]
                  # ${c.name}
                  PublicKey = ${c.PublicKey}
                  AllowedIPs = ${assignSiteClientCIDR(wg_network, site.id, c.id)}
                  `;
        })
        .join("\n")}
      `,
    );

  return config
    .join("\n\n")
    .split("\n")
    .map((line) => line.trim())
    .join("\n")
    .trim();
}

function trimSection(section: string[]) {
  return section
    .map((chunk) =>
      chunk
        .split("\n")
        .filter((l) => l.trim())
        .map((l) => l.trim())
        .join("\n"),
    )
    .join("\n");
}

function assignSiteCIRD(wg_network: string, site_id: number) {
  // keeping it at /16, but maybe it's sufficient if this is /24?
  return generateCIDR(wg_network, site_id, 1);
}

function assignSiteClientCIDR(wg_network: string, site_id: number, client_id: number) {
  // allow only traffic coming directly from the client
  return generateCIDR(wg_network, site_id, client_id, "32");
}

function assignClientCIDR(wg_network: string, site_id: number, client_id: number) {
  // client can talk to all other clients in the wg_network
  return generateCIDR(wg_network, site_id, client_id);
}

export function generateClientConfig(
  settings: Settings[],
  site: Site,
  client: Client,
  type: ClientConfigType,
) {
  const wg_network = settings.find((s) => s.name === "wg_network")!.value;

  let DNS = "";
  if (type === ClientConfigType.localOnlyDNS || type === ClientConfigType.allTrafficDNS) {
    DNS = site.DNS ?? "";
  } else if (
    type === ClientConfigType.localOnlyPiholeDNS ||
    type === ClientConfigType.allTrafficPiholeDNS
  ) {
    DNS = site.PiholeDNS ?? "";
  }

  let config = `
    [Interface]
    Address = ${assignClientCIDR(wg_network, site.id, client.id)}
    PrivateKey = ${client.PrivateKey}
    ${DNS ? `DNS = ${DNS}` : ""}

    [Peer]
    Endpoint = ${site.endpointAddress}
    PublicKey = ${site.PublicKey}
    AllowedIPs = ${
      type == ClientConfigType.localOnly ||
      type == ClientConfigType.localOnlyDNS ||
      type == ClientConfigType.localOnlyPiholeDNS
        ? [generateCIDR(wg_network, 0, 0), site.localAddresses].filter((v) => v).join(", ")
        : "0.0.0.0/0, ::/0"
    }
    `;

  config = config.replace(/^\s+/gm, ""); // Remove leading whitespace
  return config;
}
